buildscript {
    ext.kotlin_version = '1.0.0'

    repositories {
        mavenCentral()
    }

    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

plugins {
    id 'org.hidetake.ssh' version '1.3.0'
    id "org.tenne.rest" version "0.4.1"
}

apply plugin: 'java'
apply plugin: 'kotlin'

repositories {
    mavenCentral()
    maven { url "http://first.wpi.edu/FRC/roborio/maven/release" }
}

dependencies {
    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    compile "edu.wpi.first.wpilibj:wpilibJavaFinal:0.1.0-SNAPSHOT"
}

task wrapper(type: Wrapper) {
    gradleVersion = "2.11"
}

//

group "org.usfirst.frc5293"
version "1.0-SNAPSHOT"

project.ext {
    teamNumber = 5293

    deployment = new Expando(
        rootUsername: 'admin',
        rootPassword: '',

        username: 'lvuser',
        password: '',

        deployDir: "/home/lvuser",
        commandDir: "/home/lvuser",

        killCommand:
                '. /etc/profile.d/natinst-path.sh; ' +
                '/usr/local/frc/bin/frcKillRobot.sh -t -r; ' +
                'sync',

        allowedImageVersions: [ 19 ],

        jreDir: "/usr/local/frc/JRE"
    )
}

jar {
    archiveName = "FRCUserProgram.jar"

    manifest {
        attributes(
                'Main-Class': 'edu.wpi.first.wpilibj.RobotBase',
                'Robot-Class': 'org.usfirst.frc5293.impl.Robot',
                'Class-Path': '.'
        )
    }

    from {
        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

task setupRemote << {
    final def target = getTargetIP()

    remotes.create('roborio') {
        host = target
        user = deployment.username
        password = deployment.password
        knownHosts = allowAnyHosts
    }

    remotes.create('roborioRoot') {
        host = target
        user = deployment.rootUsername
        password = deployment.rootPassword
        knownHosts = allowAnyHosts
    }
}

//noinspection GroovyAssignabilityCheck
task deploySetup(dependsOn: setupRemote, type: org._10ne.gradle.rest.RestTask) << {
    httpMethod = 'post'
    uri = "http://${remotes.roborio.host}/nisysapi/server"
    username = deployment.username
    password = deployment.password
    requestBody = [
        Function: 'GetPropertiesOfItem',
        Plugins: 'nisyscfg',
        Items: 'system'
    ]
    requestContentType = groovyx.net.http.ContentType.URLENC
    contentType = groovyx.net.http.ContentType.XML
    responseHandler = {
        def response = it.message
        def pattern = ~/FRC_roboRIO_2016_v([0-9]+)/

        def version = response =~ pattern
        if (!version) {
            throw new GradleException("failed to find roboRIO image version")
        }
        version = version.group().toInteger()

        if (!deployment.allowedImageVersions.contains(version)) {
            throw new GradleException(
                    "roboRIO Image does not match plugin, allowed image version: " +
                    "${deployment.allowedImageVersions}")
        }

        logger.debug("roboRIO image version validated")
        logger.debug(
            "Checking for JRE. If this fails install the JRE using these instructions:" +
            "https://wpilib.screenstepslive.com/s/4485/m/13503/l/288822-installing-java-8-on-the-roborio-using-the-frc-roborio-java-installer-java-only")

        ssh.run {
            session(remotes.roborio) {
                execute "test -d ${deployment.jreDir}"
            }
        }
    }
}

//noinspection GroovyAssignabilityCheck
task deploy(dependsOn: [setupRemote, jar, /* deploySetup */ ]) << {
    ssh.run {
        session(remotes.roborio) {
            logger.info("Copying code over.")
            put from: jar.archivePath, into: deployment.deployDir
        }

        session(remotes.roborioRoot) {
            // Suppress the exit status so that if no netconsole was running then
            // it doesn't show up red on the output.
            execute 'killall -q netconsole-host || :'
        }

        session(remotes.roborio) {
            put from: 'remote/robotCommand', into: deployment.commandDir

            logger.info("Starting program.")
            execute deployment.killCommand
        }
    }
}

//noinspection GroovyAssignabilityCheck
task debugDeploy(dependsOn: [setupRemote, jar]) << {
    ssh.run {
        def flagDir = '/tmp/'

        session(remotes.roborio) {
            logger.info("Copying code over.")
            put from: jar.archivePath, into: deployment.deployDir

            // The remoteDebugCommand file is used by /usr/local/frc/bin/frcRunRobot.sh
            // on the roboRIO
            put from: 'remote/robotDebugCommand', into: deployment.commandDir

            // The frcdebug file is used as a flag for /usr/local/frc/bin/frcRunRobot.sh
            // to run the robot program in debug mode
            put from: 'remote/frcdebug', into: flagDir
            execute "chown lvuser:ni ${flagDir}/frcdebug"

            logger.debug("Starting debug program.")
            execute deployment.killCommand
        }
    }
}

//

private static boolean empty(String x) {
    return x == null || x.length() == 0;
}

boolean isReachableUrl(String url, int timeout) {
    logger.debug("Probing url " + url)

    String host
    try {
        URL realURL = new URL(url);
        host = realURL.getHost();

        if (empty(host)) {
            throw new InvalidUserDataException("No hostname in URL " + url);
        }
    } catch (MalformedURLException ex) {
        throw new InvalidUserDataException("Bad URL " + url, ex);
    }

    isReachable(host, timeout)
}

boolean isReachable(String host, int timeout) {
    logger.debug("Probing host " + host)

    InetAddress address
    try {
        address = InetAddress.getByName(host)
    } catch (UnknownHostException ignored) {
        logger.warn("Unknown host: " + host)
        return false;
    }

    isReachable(address, timeout)
}

boolean isReachable(InetAddress host, int timeout) {
    logger.debug("Probing host " + host)

    boolean reachable;
    try {
        reachable = host.isReachable(timeout * 1000 /* ms */)
    } catch (IOException e) {
        // any kind of fault: not reachable.
        logger.warn("network error to " + host + ": " + e.toString())
        reachable = false;
    }

    logger.debug("host is" + (reachable ? "" : " not") + " reachable")
    return reachable;
}

//


String getTargetIP() {
    String target
    final def timeout = 5 /* seconds */

    target = "roboRIO-${ext.teamNumber}-FRC.local"
    logger.info("Trying Target: ${target}")

    if (isReachable(target, timeout)) {
        logger.info("roboRIO found via mDNS")
        return target
    }

    //

    target = "172.22.11.2"
    logger.info("roboRIO not found via mDNS, falling back to static USB on $target")

    if (isReachable(target, timeout)) {
        logger.info("roboRIO found via static USB")
        return target
    }

    //

    target = {
        def upper = ext.teamNumber / 100
        def lower = ext.teamNumber % 100
        "10.$upper.$lower.2"
    }()

    logger.info("roboRIO not found via USB, falling back to static address of $target")

    if (isReachable(target, timeout)) {
        logger.info("roboRIO found via Ethernet static")
        return target
    }

    //

    throw new GradleException(
            "roboRIO not found, please check that the roboRIO is connected, imaged" +
                    " and that the team number is set properly in Eclipse")
}
